---
layout:     post
title:      CSAPP读书笔记之高速缓存
subtitle:   处理器体系结构
date:       2019-04-11
author:     kakakkk
header-img: img/Evan.jpg
catalog: true
---

### 一、通用的高速缓存存储器结构
每个存储器地址有m位，形成M=2^m个不同的地址。
机器的高速缓存被组织成一个有S=2^s个cache set的数组。每个组包含E个cache line。每个cache line是由一个B=2^b字节的数据块(block)组成的，一个有效位(valid bit)
指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位(tag bit)(是当前块的存储器的位的一个子集)它们唯一地标识存储在这个高速缓存行中的块。
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-27-1.png)


高速缓存是一个高速缓存组的数组，每个组包含一个或多个cache line，每个cache line包含一个有效位，一些标记位，以及一个数据块。
高速缓存的结构将m个地址位划分成了t个标记位(当标记位每个有效位都是0时，表示高速缓存是空)、s个索引位(组索引解释为无符号整数，告知了字必须存储在哪个组中)和b个块偏移位(给出了在B个字节的数据块中的字的偏移量)。
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-27-2.png)


#### 高速缓存的结构表示
高速缓存的结构可以用元组(S,E,B,m)来描述，高速缓存的大小(或容量)C指的是所有块的大小之和。标记位和有效位不包括。C=S*E*B。


#### 举例：从主存地址A读一个字
当一条加载指令指示CPU从主存地址A中读一个字时，它将地址A发送到高速缓存。如果高速缓存正保存着地址A处那个字的拷贝，它就立即将字发回给CPU。(高速缓存的结构使得它能通过简单地检查地址位，找到所请求的字)

#### 高速缓存相关基本参数
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-27-2.png)

#### 直接映射高速缓存
根据E(每个组的高速缓存行数)高速缓存被分为不同的类。
E=1的高速缓存称为直接映射高速缓存。


#### 缓存命中
当程序需要第k+1层的某个数据对象d时，它首先会在第K层的一个块中查找d。如果d缓存在第K层中，则称缓存命中。反之没命中，此时会从K+1层中缓存d所在的块，如果K满了，则会出现覆盖现存的块的情况。

高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程：
1）组选择
2）行匹配
3）字抽取

### 二、直接映射高速缓存中的组选择
高速缓存需从取出字w的地址中间取出s个组索引位。
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-30.png)

#### 直接映射高速缓存中的行匹配
目的是确定是否有字w的一个拷贝存储在组i包含的一个高速缓存行中。当且仅当设置了有效位，且高速缓存行中的标记与字w的地址中的标记位相匹配时，这行中包含数据对象的一个拷贝。

#### 直接映射高速缓存中的字选择
目的是确定所需要的字在块中从哪里开始。块偏移量提供了所需字的第一个字节的偏移。(假设字长4字节)
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-31.png)
(w0表示字w的低位字节，w1是下一个字节……以此类推)

#### 直接映射高速缓存中不命中时的行替换
一般而言，如果组中都是有效高速缓存行，如果缓存不命中，那么必须驱逐出一个现行的行。在直接映射高速缓存中直接将新取出的行代替当前的行即可。

#### 运行中的直接映射高速缓存
假设：(S,E,B,m)=(4,1,2,4)
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-32.png)
##### 注意：标记位和索引位连起来唯一地标识了存储器中地每一块。例如：块0是由地址0和1组成，块1由地址2和3组成，块2是由地址3和4组成，以此类推……
CPU执行一系列读时的操作：
如下是cache line 和 block的关系:
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-32-1.jpg)
1）读地址0的字。因为组0的有效位是0，是缓存不命中。高速缓存从存储器(或低一层的高速缓存)取出块0，并把这个块存储在组0中。高速缓存返回新取出的高速缓存行的块[0]的m[0](存储器位置0的内容)

2)读地址1的字。高速缓存命中，高速缓存立即从高速缓存行的块[1]中返回m[1]。高速缓存的状态没有变化。

3)读地址13的字。由于组2中的高速缓存行不是有效的，所以有缓存不命中。高速缓存把块6加载到组2中，再从新的高速缓存行的块[1]中返回m[13]。

4)读地址8的字。这会发生缓存不命中。组0中的高速缓存行确实是有效的，但是标记不匹配。高速缓存将块4加载到组0中(替换读地址0时读入的那一行)，再从新的高速缓存行的块[0]中返回m[8]。

5)读地址0的字。又会发生缓冲不命中，因为在前面引用地址8时，我们刚好替换了块0。这种情况也称为冲突不命中。

#### 直接映射高速缓存中的冲突不命中
当程序访问大小为2的幂的数组时，直接映射高速缓存中通常会发生冲突不命中。
程序举例：考虑一个计算两个向量点积的函数时。
##### float dotprod(float x[8],float y[8]){
##### 	float sum = 0.0;
##### 	int i;
##### 	for(i = 0;i<8;i++)
##### 		sum+=x[i]*y[i];
##### 	return sum;
##### }

分析：x会被加载到从地址0开始的32个字节连续存储器中，而y紧跟在x之后，从地址32开始。假设一个块是16个字节，高速缓存由两个组组成，高速缓存的整个大小为32个字节。假设变量sum实际上存放在一个CPU寄存器中，因此不需要存储器引用。根据这些假设每个x[i]和y[i]会映射到相同的高速缓存组：
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-32-2.png)
在运行时，循环的第一次迭代引用x[0],缓存不命中会导致包含x[0]~x[3]的块被加载到组0.接下来是对y[0]的引用，又一次缓存不命中，导致包含y[0]~y[3]的块被拷贝到组0，覆盖前一次引用拷贝进来的x的值。在下一次迭代中，x[1]的引用不命中，导致x[0]~x[3]的块被加载回组0，覆盖掉y[0]~y[3]的块。因此出现了冲突不命中。

解决方法：在每个数组的结尾放B字节的填充。
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-32-3.png)

### 三、组相联高速缓存
1<E<C/B的高速缓存通常称为E路组相联高速缓存。

1)组相联高速缓存中的组选择
与直接映射高速缓存的组选择一样，组索引位标识组。

2)组相联高速缓存中的行匹配和字选择
一个传统的存储器是一个值的数组，以地址作为输入，并返回存储在那个地址的值。另一方面，一个相联的存储器是一个(key,value)对的数组，以key为输入，返回与输入的key相匹配的(key,value)对中的value值。故可将组相联高速缓存中的每个组都看成一个小的相联存储器，key是标记和有效位，而value是块的内容。

如下是2路组相联高速缓存：
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-34.png)

#### 组相联高速缓存中不命中时的行替换
当CPU请求的字不在组的任何一行中，则缓存不命中，高速缓存必须从存储器中取出包含这个字的块。当不存在空行，需从中选择一个非空行，希望CPU不会和快引用这个被代替的行。


### 四、全相联高速缓存
一个全相联高速缓存是由一个包含所有高速缓存行的组，即E=C/B。
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-37.png)

1)全相联高速缓存中的组选择
由于全相联高速缓存中只有一个组，因此地址中并没有组索引位，地址只被划分成一个标记和一个块偏移。

2)全相联高速缓存中的行匹配和字选择
与组相联高速缓存一样。


### 五、有关高速缓存写问题
假设写一个已经缓存了的字w写命中。
更新w在层次结构中紧接着低一层中的拷贝的方法：
1)直写：即立即将w的高速缓存块写回到紧接着的低一层中。

2)写回：尽可能延迟存储器的更新，只有当替换算法要驱逐更新过的块时，才把它写回。高速缓存必须为每个高速缓存行维护一个额外的修改位，表明这个高速缓存块是否被修改过。

#### 处理写不出命中
1)写分配：加载相应的低一层中的块到高速缓存中，再更新这个高速缓存块。

2)非写分配：避开高速缓存，直接把这个字写到低一层中。

直写高速缓存通常是非写分配，写回高速缓存通常是写分配的。


### 六、一个真实的高速缓存层次结构的解剖
高速缓存既保存数据，也保存指令。只保存指令的高速缓存称为i-cache，只保存程序数据的高速缓存称为d-cache。既保存指令又包括数据的高速缓存称为统一的高速缓存。

以下是Intel Core i7处理器的高速缓存层次结构：
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-40.png)

Core i7高速缓存层次结构的特性：
![img](https://github.com/kakakkk/kakakkk.github.io/raw/master/img/post-6-41.png)


### 七、高速缓存参数的性能影响

1)不命中率：在一个程序执行或程序的一部分执行期间，存储器引用不命中的比率。不命中数量/引用数量。

2)命中率：命中率的存储器引用比率。

3)命中时间：从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择。对于L1高速缓存来说，命中时间的数量级是几个时钟周期。

4)不命中处罚：由于不命中需要的额外时间。

##### 高速缓存大小的影响
1)较大的高速缓存可能会提高命中率。

2)较大的高速缓存可能会增加命中时间。

##### 块大小的影响
1)较大的块能利用程序中可能存在的空间局部性，帮助提高命中率

2)对于给定的高速缓存大小，块越大就意味着高速缓存行数越少，会损害时间局部性比空间局部性更好的程序中的命中率。

3)块越大，传送时间就越长。

##### 相联度的影响
较高的相联度的优点是降低了高速缓存由于冲突不命中出现抖动的可能性。但很难使之速度变快，每行需要更多的标记位，每一行需要额外的LRU状态位和额外的控制逻辑。


### 编写高速缓存友好的代码
基本方法：
1)让最常见的情况运行得快。

2)在每个循环内部缓存不命中数量最小。

### 日常叨叨
emmmmm叨不了了......
